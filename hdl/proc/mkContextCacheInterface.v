//
// Generated by Bluespec Compiler, version 2023.07 (build 0eb551d)
//
// On Tue Jul  9 11:58:12 EDT 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_putMemResp                 O     1 reg
// getMemReq                      O   539 reg
// RDY_getMemReq                  O     1 reg
// RDY_sendReqData                O     1
// getRespData                    O    32 reg
// RDY_getRespData                O     1 reg
// RDY_sendReqInstr               O     1
// getRespInstr                   O    32 reg
// RDY_getRespInstr               O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// putMemResp_resp                I   512 reg
// sendReqData_req                I    68
// sendReqInstr_req               I    68
// EN_putMemResp                  I     1
// EN_sendReqData                 I     1
// EN_sendReqInstr                I     1
// EN_getMemReq                   I     1
// EN_getRespData                 I     1
// EN_getRespInstr                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkContextCacheInterface(CLK,
			       RST_N,

			       putMemResp_resp,
			       EN_putMemResp,
			       RDY_putMemResp,

			       EN_getMemReq,
			       getMemReq,
			       RDY_getMemReq,

			       sendReqData_req,
			       EN_sendReqData,
			       RDY_sendReqData,

			       EN_getRespData,
			       getRespData,
			       RDY_getRespData,

			       sendReqInstr_req,
			       EN_sendReqInstr,
			       RDY_sendReqInstr,

			       EN_getRespInstr,
			       getRespInstr,
			       RDY_getRespInstr);
  input  CLK;
  input  RST_N;

  // action method putMemResp
  input  [511 : 0] putMemResp_resp;
  input  EN_putMemResp;
  output RDY_putMemResp;

  // actionvalue method getMemReq
  input  EN_getMemReq;
  output [538 : 0] getMemReq;
  output RDY_getMemReq;

  // action method sendReqData
  input  [67 : 0] sendReqData_req;
  input  EN_sendReqData;
  output RDY_sendReqData;

  // actionvalue method getRespData
  input  EN_getRespData;
  output [31 : 0] getRespData;
  output RDY_getRespData;

  // action method sendReqInstr
  input  [67 : 0] sendReqInstr_req;
  input  EN_sendReqInstr;
  output RDY_sendReqInstr;

  // actionvalue method getRespInstr
  input  EN_getRespInstr;
  output [31 : 0] getRespInstr;
  output RDY_getRespInstr;

  // signals for module outputs
  wire [538 : 0] getMemReq;
  wire [31 : 0] getRespData, getRespInstr;
  wire RDY_getMemReq,
       RDY_getRespData,
       RDY_getRespInstr,
       RDY_putMemResp,
       RDY_sendReqData,
       RDY_sendReqInstr;

  // register reqTypePriority
  reg reqTypePriority;
  wire reqTypePriority$D_IN, reqTypePriority$EN;

  // ports of submodule cacheD
  wire [538 : 0] cacheD$getToMem;
  wire [511 : 0] cacheD$putFromMem_e;
  wire [67 : 0] cacheD$putFromProc_e;
  wire [31 : 0] cacheD$getToProc;
  wire cacheD$EN_getToMem,
       cacheD$EN_getToProc,
       cacheD$EN_putFromMem,
       cacheD$EN_putFromProc,
       cacheD$RDY_getToMem,
       cacheD$RDY_getToProc,
       cacheD$RDY_putFromMem,
       cacheD$RDY_putFromProc;

  // ports of submodule cacheI
  wire [538 : 0] cacheI$getToMem;
  wire [511 : 0] cacheI$putFromMem_e;
  wire [67 : 0] cacheI$putFromProc_e;
  wire [31 : 0] cacheI$getToProc;
  wire cacheI$EN_getToMem,
       cacheI$EN_getToProc,
       cacheI$EN_putFromMem,
       cacheI$EN_putFromProc,
       cacheI$RDY_getToMem,
       cacheI$RDY_getToProc,
       cacheI$RDY_putFromMem,
       cacheI$RDY_putFromProc;

  // ports of submodule cacheL2
  wire [538 : 0] cacheL2$getToMem, cacheL2$putFromProc_e;
  wire [511 : 0] cacheL2$getToProc, cacheL2$putFromMem_e;
  wire cacheL2$EN_getToMem,
       cacheL2$EN_getToProc,
       cacheL2$EN_putFromMem,
       cacheL2$EN_putFromProc,
       cacheL2$RDY_getToMem,
       cacheL2$RDY_getToProc,
       cacheL2$RDY_putFromMem,
       cacheL2$RDY_putFromProc;

  // ports of submodule dataL2RespQ
  wire [511 : 0] dataL2RespQ$D_IN, dataL2RespQ$D_OUT;
  wire dataL2RespQ$CLR,
       dataL2RespQ$DEQ,
       dataL2RespQ$EMPTY_N,
       dataL2RespQ$ENQ,
       dataL2RespQ$FULL_N;

  // ports of submodule instL2RespQ
  wire [511 : 0] instL2RespQ$D_IN, instL2RespQ$D_OUT;
  wire instL2RespQ$CLR,
       instL2RespQ$DEQ,
       instL2RespQ$EMPTY_N,
       instL2RespQ$ENQ,
       instL2RespQ$FULL_N;

  // ports of submodule reqQL2
  wire [538 : 0] reqQL2$D_IN, reqQL2$D_OUT;
  wire reqQL2$CLR, reqQL2$DEQ, reqQL2$EMPTY_N, reqQL2$ENQ, reqQL2$FULL_N;

  // ports of submodule reqTypeQ
  wire reqTypeQ$CLR,
       reqTypeQ$DEQ,
       reqTypeQ$D_IN,
       reqTypeQ$D_OUT,
       reqTypeQ$EMPTY_N,
       reqTypeQ$ENQ,
       reqTypeQ$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_connectL1DataL2,
       WILL_FIRE_RL_connectL1InstL2,
       WILL_FIRE_RL_distributeL2Resp;

  // inputs to muxes for submodule ports
  wire MUX_reqTypeQ$enq_1__SEL_1;

  // remaining internal signals
  wire reqTypeQ_i_notEmpty__3_AND_IF_reqTypeQ_first___ETC___d28;

  // action method putMemResp
  assign RDY_putMemResp = cacheL2$RDY_putFromMem ;

  // actionvalue method getMemReq
  assign getMemReq = cacheL2$getToMem ;
  assign RDY_getMemReq = cacheL2$RDY_getToMem ;

  // action method sendReqData
  assign RDY_sendReqData = cacheD$RDY_putFromProc ;

  // actionvalue method getRespData
  assign getRespData = cacheD$getToProc ;
  assign RDY_getRespData = cacheD$RDY_getToProc ;

  // action method sendReqInstr
  assign RDY_sendReqInstr = cacheI$RDY_putFromProc ;

  // actionvalue method getRespInstr
  assign getRespInstr = cacheI$getToProc ;
  assign RDY_getRespInstr = cacheI$RDY_getToProc ;

  // submodule cacheD
  mkCache32 cacheD(.CLK(CLK),
		   .RST_N(RST_N),
		   .putFromMem_e(cacheD$putFromMem_e),
		   .putFromProc_e(cacheD$putFromProc_e),
		   .EN_putFromProc(cacheD$EN_putFromProc),
		   .EN_getToProc(cacheD$EN_getToProc),
		   .EN_getToMem(cacheD$EN_getToMem),
		   .EN_putFromMem(cacheD$EN_putFromMem),
		   .RDY_putFromProc(cacheD$RDY_putFromProc),
		   .getToProc(cacheD$getToProc),
		   .RDY_getToProc(cacheD$RDY_getToProc),
		   .getToMem(cacheD$getToMem),
		   .RDY_getToMem(cacheD$RDY_getToMem),
		   .RDY_putFromMem(cacheD$RDY_putFromMem));

  // submodule cacheI
  mkCache32 cacheI(.CLK(CLK),
		   .RST_N(RST_N),
		   .putFromMem_e(cacheI$putFromMem_e),
		   .putFromProc_e(cacheI$putFromProc_e),
		   .EN_putFromProc(cacheI$EN_putFromProc),
		   .EN_getToProc(cacheI$EN_getToProc),
		   .EN_getToMem(cacheI$EN_getToMem),
		   .EN_putFromMem(cacheI$EN_putFromMem),
		   .RDY_putFromProc(cacheI$RDY_putFromProc),
		   .getToProc(cacheI$getToProc),
		   .RDY_getToProc(cacheI$RDY_getToProc),
		   .getToMem(cacheI$getToMem),
		   .RDY_getToMem(cacheI$RDY_getToMem),
		   .RDY_putFromMem(cacheI$RDY_putFromMem));

  // submodule cacheL2
  mkCache cacheL2(.CLK(CLK),
		  .RST_N(RST_N),
		  .putFromMem_e(cacheL2$putFromMem_e),
		  .putFromProc_e(cacheL2$putFromProc_e),
		  .EN_putFromProc(cacheL2$EN_putFromProc),
		  .EN_getToProc(cacheL2$EN_getToProc),
		  .EN_getToMem(cacheL2$EN_getToMem),
		  .EN_putFromMem(cacheL2$EN_putFromMem),
		  .RDY_putFromProc(cacheL2$RDY_putFromProc),
		  .getToProc(cacheL2$getToProc),
		  .RDY_getToProc(cacheL2$RDY_getToProc),
		  .getToMem(cacheL2$getToMem),
		  .RDY_getToMem(cacheL2$RDY_getToMem),
		  .RDY_putFromMem(cacheL2$RDY_putFromMem));

  // submodule dataL2RespQ
  FIFO2 #(.width(32'd512), .guarded(1'd1)) dataL2RespQ(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(dataL2RespQ$D_IN),
						       .ENQ(dataL2RespQ$ENQ),
						       .DEQ(dataL2RespQ$DEQ),
						       .CLR(dataL2RespQ$CLR),
						       .D_OUT(dataL2RespQ$D_OUT),
						       .FULL_N(dataL2RespQ$FULL_N),
						       .EMPTY_N(dataL2RespQ$EMPTY_N));

  // submodule instL2RespQ
  FIFO2 #(.width(32'd512), .guarded(1'd1)) instL2RespQ(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(instL2RespQ$D_IN),
						       .ENQ(instL2RespQ$ENQ),
						       .DEQ(instL2RespQ$DEQ),
						       .CLR(instL2RespQ$CLR),
						       .D_OUT(instL2RespQ$D_OUT),
						       .FULL_N(instL2RespQ$FULL_N),
						       .EMPTY_N(instL2RespQ$EMPTY_N));

  // submodule reqQL2
  FIFO2 #(.width(32'd539), .guarded(1'd1)) reqQL2(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(reqQL2$D_IN),
						  .ENQ(reqQL2$ENQ),
						  .DEQ(reqQL2$DEQ),
						  .CLR(reqQL2$CLR),
						  .D_OUT(reqQL2$D_OUT),
						  .FULL_N(reqQL2$FULL_N),
						  .EMPTY_N(reqQL2$EMPTY_N));

  // submodule reqTypeQ
  FIFO2 #(.width(32'd1), .guarded(1'd1)) reqTypeQ(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(reqTypeQ$D_IN),
						  .ENQ(reqTypeQ$ENQ),
						  .DEQ(reqTypeQ$DEQ),
						  .CLR(reqTypeQ$CLR),
						  .D_OUT(reqTypeQ$D_OUT),
						  .FULL_N(reqTypeQ$FULL_N),
						  .EMPTY_N(reqTypeQ$EMPTY_N));

  // rule RL_connectL1InstL2
  assign WILL_FIRE_RL_connectL1InstL2 =
	     cacheI$RDY_getToMem && reqQL2$FULL_N && reqTypeQ$FULL_N &&
	     !reqTypePriority ;

  // rule RL_connectL1DataL2
  assign WILL_FIRE_RL_connectL1DataL2 =
	     cacheD$RDY_getToMem && reqQL2$FULL_N && reqTypeQ$FULL_N &&
	     reqTypePriority ;

  // rule RL_distributeL2Resp
  assign WILL_FIRE_RL_distributeL2Resp =
	     cacheL2$RDY_getToProc &&
	     reqTypeQ_i_notEmpty__3_AND_IF_reqTypeQ_first___ETC___d28 ;

  // inputs to muxes for submodule ports
  assign MUX_reqTypeQ$enq_1__SEL_1 =
	     WILL_FIRE_RL_connectL1InstL2 && !cacheI$getToMem[538] ;

  // register reqTypePriority
  assign reqTypePriority$D_IN = !reqTypePriority ;
  assign reqTypePriority$EN = 1'd1 ;

  // submodule cacheD
  assign cacheD$putFromMem_e = dataL2RespQ$D_OUT ;
  assign cacheD$putFromProc_e = sendReqData_req ;
  assign cacheD$EN_putFromProc = EN_sendReqData ;
  assign cacheD$EN_getToProc = EN_getRespData ;
  assign cacheD$EN_getToMem = WILL_FIRE_RL_connectL1DataL2 ;
  assign cacheD$EN_putFromMem = cacheD$RDY_putFromMem && dataL2RespQ$EMPTY_N ;

  // submodule cacheI
  assign cacheI$putFromMem_e = instL2RespQ$D_OUT ;
  assign cacheI$putFromProc_e = sendReqInstr_req ;
  assign cacheI$EN_putFromProc = EN_sendReqInstr ;
  assign cacheI$EN_getToProc = EN_getRespInstr ;
  assign cacheI$EN_getToMem = WILL_FIRE_RL_connectL1InstL2 ;
  assign cacheI$EN_putFromMem = cacheI$RDY_putFromMem && instL2RespQ$EMPTY_N ;

  // submodule cacheL2
  assign cacheL2$putFromMem_e = putMemResp_resp ;
  assign cacheL2$putFromProc_e = reqQL2$D_OUT ;
  assign cacheL2$EN_putFromProc = cacheL2$RDY_putFromProc && reqQL2$EMPTY_N ;
  assign cacheL2$EN_getToProc = WILL_FIRE_RL_distributeL2Resp ;
  assign cacheL2$EN_getToMem = EN_getMemReq ;
  assign cacheL2$EN_putFromMem = EN_putMemResp ;

  // submodule dataL2RespQ
  assign dataL2RespQ$D_IN = cacheL2$getToProc ;
  assign dataL2RespQ$ENQ = WILL_FIRE_RL_distributeL2Resp && reqTypeQ$D_OUT ;
  assign dataL2RespQ$DEQ = cacheD$RDY_putFromMem && dataL2RespQ$EMPTY_N ;
  assign dataL2RespQ$CLR = 1'b0 ;

  // submodule instL2RespQ
  assign instL2RespQ$D_IN = cacheL2$getToProc ;
  assign instL2RespQ$ENQ = WILL_FIRE_RL_distributeL2Resp && !reqTypeQ$D_OUT ;
  assign instL2RespQ$DEQ = cacheI$RDY_putFromMem && instL2RespQ$EMPTY_N ;
  assign instL2RespQ$CLR = 1'b0 ;

  // submodule reqQL2
  assign reqQL2$D_IN =
	     WILL_FIRE_RL_connectL1InstL2 ?
	       cacheI$getToMem :
	       cacheD$getToMem ;
  assign reqQL2$ENQ =
	     WILL_FIRE_RL_connectL1InstL2 || WILL_FIRE_RL_connectL1DataL2 ;
  assign reqQL2$DEQ = cacheL2$RDY_putFromProc && reqQL2$EMPTY_N ;
  assign reqQL2$CLR = 1'b0 ;

  // submodule reqTypeQ
  assign reqTypeQ$D_IN = !MUX_reqTypeQ$enq_1__SEL_1 ;
  assign reqTypeQ$ENQ =
	     WILL_FIRE_RL_connectL1InstL2 && !cacheI$getToMem[538] ||
	     WILL_FIRE_RL_connectL1DataL2 && !cacheD$getToMem[538] ;
  assign reqTypeQ$DEQ = WILL_FIRE_RL_distributeL2Resp ;
  assign reqTypeQ$CLR = 1'b0 ;

  // remaining internal signals
  assign reqTypeQ_i_notEmpty__3_AND_IF_reqTypeQ_first___ETC___d28 =
	     reqTypeQ$EMPTY_N &&
	     (reqTypeQ$D_OUT ? dataL2RespQ$FULL_N : instL2RespQ$FULL_N) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        reqTypePriority <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (reqTypePriority$EN)
	  reqTypePriority <= `BSV_ASSIGNMENT_DELAY reqTypePriority$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    reqTypePriority = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_getMemReq && cacheL2$getToMem[538])
	$display("[mm.write] %x\n\t%x",
		 cacheL2$getToMem[537:512],
		 cacheL2$getToMem[511:0]);
  end
  // synopsys translate_on
endmodule  // mkContextCacheInterface

